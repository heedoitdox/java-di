# 🚀 3단계 - @Configuration 구현하기

# **미션 설명**

현재 dao 클래스는 데이터베이스가 아닌 Map을 사용하여 저장하고 있다.

일반적인 웹 서비스는 데이터를 데이터베이스에 저장한다.

추후에 데이터베이스에 연결할 수 있도록 javax.sql.DataSource로 데이터베이스 설정 정보를 관리하자.

데이터베이스 설정 정보를 하드 코딩하면 관리가 어려우니 @Configuration 기능을 추가하여 빈 인스턴스로 관리할 수 있도록 만든다.

데이터베이스는 임시로 h2를 사용한다. 나중에 데이터베이스를 변경하게 된다면 데이터베이스 설정 정보를 담당하는 빈을 수정하면 된다.

## **요구사항**

- 데이터베이스 설정을 관리하는 책임을 맡은 빈을 생성하기 위해 @Configuration을 추가하자. 각 메소드에서 생성하는 인스턴스가 BeanFactory에 빈으로 등록하라는 설정은 @Bean으로 한다.
- BeanScanner에서 사용할 기본 패키지에 대한 설정을 하드코딩했는데 @ComponentScan으로 패키지 경로를 설정할 수 있도록 지원하자.
- @Configuration 설정 파일을 통해 등록한 빈과 BeanScanner를 통해 등록한 빈 간에도 DI가 가능해야 한다.

### **@Configuration 예제**

```java
import org.h2.jdbcx.JdbcDataSource;
import javax.sql.DataSource;

@Configuration
@ComponentScan({ "camp.nextstep", "com.interface21" })
public class MyConfiguration {

    @Bean
    public DataSource dataSource() {
        final var jdbcDataSource = new JdbcDataSource();
        jdbcDataSource.setUrl("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;");
        jdbcDataSource.setUser("");
        jdbcDataSource.setPassword("");
        return jdbcDataSource;
    }

    @Bean
    public JdbcTemplate jdbcTemplate(final DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

---
## 요구사항 정리

1. DataSource 로 데이터베이스 설정 정보를 관리한다.
   - [x] DataSource 빈이 생성될 수 있도록 예제 코드를 작성한다
   - [x] JdbcTemplate 빈이 생성될 수 있도록 예제 작성한다
2. @ComponentScan 으로 패키지 경로를 설정할 수 있도록 지원한다
   - [x] @ComponentScan 애노테이션의 basePackages 값을 조회한 뒤 리플렉션으로 클래스들을 조회한다
   - [ ] BeanScanner 에서도 조회한 basePackages 를 사용할 수 있도록 리팩토링한다 
3. @Configuration 설정파일을 통해 빈을 등록할 수 있어야한다
   - [ ] @Bean 애노테이션이 붙은 메서드의 리턴타입을 빈으로 만든다
   - [x] ConfigurationBeanScanner 를 구현하여 주입해야할 어노테이션이 붙은 클래스들을 스캔한다
   - [ ] Method 정보를 멤버변수로 가지는 BeanDefinition 구현체를 만든다 
4. 리팩터링
   - [x] BeanDefinitionRegistry 구현체를 만들어서 BeanDefinition 객체를 등록, 조회 할 수 있도록 한다
   - [x] GenericBeanDefinition 객체 내에서 인스턴스를 생성할 수 있는 메서드를 만들어 생성 역할을 분리한다 